package handlers

import (
	"cargozig_api/models"
	"fmt"
	"os"
	"strings"
	"time"

	"github.com/gofiber/fiber/v2"
	"github.com/golang-jwt/jwt/v5"
	"golang.org/x/crypto/bcrypt"
)

// JWT secret key (store this in an environment variable)
var jwtSecret = []byte(os.Getenv("JWT_SECRET"))

// Initialize checks and configurations
func init() {
	// Check if JWT_SECRET is set
	if len(jwtSecret) == 0 {
		fmt.Println("Error: JWT_SECRET environment variable is not set")
		os.Exit(1)
	}
}

// SetupApiAuthRoutes sets up the authentication routes
func SetupApiAuthRoutes(router fiber.Router) {
	router.Post("/login", UserLogin)
	router.Post("/logout", UserLogout)
	router.Get("/protected", ProtectedRoute)
	router.Post("/register", RegisterNewUser)
}

// GenerateJWT creates a JWT token
func GenerateJWT(userID string) (string, error) {
	// Define claims for the token
	claims := jwt.MapClaims{
		"user_id": userID,
		"exp":     time.Now().Add(time.Hour * 24).Unix(), // Expires in 24 hours
	}

	// Create a new token with claims
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	// Sign the token with the secret
	return token.SignedString(jwtSecret)
}

// RegisterNewUser handles user registration and sets a JWT cookie
func RegisterNewUser(c *fiber.Ctx) error {
	var req struct {
		Username string `json:"username"`
		Email    string `json:"email"`
		Password string `json:"password"`
	}

	// Parse request body
	if err := c.BodyParser(&req); err != nil {
		fmt.Println("Error parsing request body:", err)
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": "Invalid request body"})
	}

	// Validate input
	if req.Username == "" || req.Email == "" || req.Password == "" {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": "Missing required fields"})
	}

	// Trim spaces
	req.Username = strings.TrimSpace(req.Username)
	req.Email = strings.TrimSpace(req.Email)

	// Check if user already exists
	var existingUser models.User
	if err := db.Where("email = ?", req.Email).First(&existingUser).Error; err == nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": "User already exists"})
	}

	// Hash password using bcrypt
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
	if err != nil {
		fmt.Println("Error hashing password:", err)
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{"error": "Failed to hash password"})
	}

	// Create new user
	newUser := models.User{
		// new uuid will be generated by the before create hook
		Username: req.Username,
		Email:    req.Email,
		Password: string(hashedPassword),
	}

	// Save user to the database
	if err := db.Create(&newUser).Error; err != nil {
		fmt.Println("Error creating user:", err)
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{"error": "Could not create user"})
	}

	// Generate JWT token
	token, err := GenerateJWT(newUser.ID.String())
	if err != nil {
		fmt.Println("Error generating token:", err)
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{"error": "Could not generate token"})
	}

	// Set JWT as an HTTP-only cookie
	var secure bool = true
	var sameSite string = "Strict"
	if os.Getenv("ENVIRONMENT") == "development" {
		secure = false
		sameSite = "None"
	}

	c.Cookie(&fiber.Cookie{
		Name:     "auth_token",
		Value:    token,
		Expires:  time.Now().Add(24 * time.Hour),
		HTTPOnly: true,     // Prevents JavaScript access
		Secure:   secure,   // Works only on HTTPS by default
		SameSite: sameSite, // Strict, Lax, None
	})

	return c.Status(fiber.StatusCreated).JSON(fiber.Map{
		"status":  "success",
		"message": "User registered successfully",
		"user_id": newUser.ID,
		"token":   token,
		"user":    newUser,
	})
}

// UserLogin authenticates the user and returns a JWT in a secure cookie
func UserLogin(c *fiber.Ctx) error {
	var loginRequest struct {
		Email    string `json:"email"`
		Password string `json:"password"`
	}

	// Parse the request body
	if err := c.BodyParser(&loginRequest); err != nil {
		fmt.Println("Error parsing login request:", err)
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": "Invalid request"})
	}

	// Find user in the database
	var user models.User
	if err := db.Where("email = ?", loginRequest.Email).First(&user).Error; err != nil {
		return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{"error": "Invalid email or password"})
	}

	// Compare the hashed password
	if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(loginRequest.Password)); err != nil {
		return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{"error": "Invalid email or password"})
	}

	// Generate JWT token
	token, err := GenerateJWT(user.ID.String())
	if err != nil {
		fmt.Println("Error generating token:", err)
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{"error": "Failed to generate token"})
	}

	// Set JWT as an HTTP-only cookie
	c.Cookie(&fiber.Cookie{
		Name:     "auth_token",
		Value:    token,
		Expires:  time.Now().Add(24 * time.Hour),
		HTTPOnly: true, // Prevents JavaScript access
		Secure:   true, // Ensures it only works over HTTPS
		SameSite: "Strict",
	})

	return c.JSON(fiber.Map{
		"status":  "success",
		"message": "Login successful",
	})
}

// UserLogout clears the authentication cookie
func UserLogout(c *fiber.Ctx) error {
	// Clear the auth token cookie
	c.Cookie(&fiber.Cookie{
		Name:     "auth_token",
		Value:    "",
		Expires:  time.Now().Add(-time.Hour), // Expire immediately
		HTTPOnly: true,
		Secure:   true,
		SameSite: "Strict",
	})

	return c.JSON(fiber.Map{"status": "success", "message": "Logged out"})
}

// ProtectedRoute example (require authentication)
func ProtectedRoute(c *fiber.Ctx) error {
	// Get JWT token from cookie
	tokenString := c.Cookies("auth_token")
	if tokenString == "" {
		return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{"error": "Unauthorized"})
	}

	// Validate JWT token
	token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
		return jwtSecret, nil
	})
	if err != nil || !token.Valid {
		return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{"error": "Invalid token"})
	}

	// Extract user ID from claims
	claims, ok := token.Claims.(jwt.MapClaims)
	if !ok {
		return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{"error": "Invalid token claims"})
	}

	userID := claims["user_id"].(string)

	return c.JSON(fiber.Map{
		"status":  "success",
		"message": "Welcome!",
		"user_id": userID},
	)

}
